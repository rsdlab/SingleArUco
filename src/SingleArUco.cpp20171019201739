// -*- C++ -*-
/*!
 * @file  SingleArUco.cpp
 * @brief ModuleDescription
 * @date $Date$
 *
 * $Id$
 */

#include "SingleArUco.h"

// Module specification
// <rtc-template block="module_spec">
static const char* singlearuco_spec[] =
  {
    "implementation_id", "SingleArUco",
    "type_name",         "SingleArUco",
    "description",       "ModuleDescription",
    "version",           "1.0.0",
    "vendor",            "Yuki_Takamido",
    "category",          "Category",
    "activity_type",     "PERIODIC",
    "kind",              "DataFlowComponent",
    "max_instance",      "1",
    "language",          "C++",
    "lang_type",         "compile",
    // Configuration variables
    "conf.default.MarkerSize", "0.05",
    "conf.default.Dictionary", "ORIGINAL",

    // Widget
    "conf.__widget__.MarkerSize", "text",
    "conf.__widget__.Dictionary", "radio",
    // Constraints
    "conf.__constraints__.Dictionary", "(ORIGINAL,4x4_50,4x4_100,4x4_250,4x4_1000,5x5_50,5x5_100,5x5_250,5x5_1000,6x6_50,6x6_100,6x6_250,6x6_1000,7x7_50,7x7_100,7x7_250,7x7_1000)",

    "conf.__type__.MarkerSize", "double",
    "conf.__type__.Dictionary", "string",

    ""
  };
// </rtc-template>

/*!
 * @brief constructor
 * @param manager Maneger Object
 */
SingleArUco::SingleArUco(RTC::Manager* manager)
    // <rtc-template block="initializer">
  : RTC::DataFlowComponentBase(manager),
    m_InImageIn("InImage", m_InImage),
    m_OutImageOut("OutImage", m_OutImage),
    m_arUcoPoint2DOut("arUcoPoint2D", m_arUcoPoint2D),
    m_arUcoPose3DOut("arUcoPose3D", m_arUcoPose3D)

    // </rtc-template>
{
}

/*!
 * @brief destructor
 */
SingleArUco::~SingleArUco()
{
}



RTC::ReturnCode_t SingleArUco::onInitialize()
{
  // Registration: InPort/OutPort/Service
  // <rtc-template block="registration">
  // Set InPort buffers
  addInPort("InImage", m_InImageIn);
  
  // Set OutPort buffer
  addOutPort("OutImage", m_OutImageOut);
  addOutPort("arUcoPoint2D", m_arUcoPoint2DOut);
  addOutPort("arUcoPose3D", m_arUcoPose3DOut);
  
  // Set service provider to Ports
  
  // Set service consumers to Ports
  
  // Set CORBA Service Ports
  
  // </rtc-template>

  // <rtc-template block="bind_config">
  // Bind variables and configuration variable
  bindParameter("MarkerSize", m_MarkerSize, "0.05");
  bindParameter("Dictionary", m_Dictionary, "ORIGINAL");
  // </rtc-template>
  
  return RTC::RTC_OK;
}

/*
RTC::ReturnCode_t SingleArUco::onFinalize()
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t SingleArUco::onStartup(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t SingleArUco::onShutdown(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/


RTC::ReturnCode_t SingleArUco::onActivated(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}


RTC::ReturnCode_t SingleArUco::onDeactivated(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}


RTC::ReturnCode_t SingleArUco::onExecute(RTC::UniqueId ec_id)
{
  //Inport data check
  //データポートが更新されているかの確認
  if(m_InImageIn.isNew())
    {
      m_InImageIn.read();//データポートを読み込む

      width=m_InImage.data.image.width;//データポートから画像幅を取得
      height=m_InImage.data.image.height;//データポートから画像の高さを取得
      channnels=(m_InImage.data.image.format == Img::CF_GRAY) ? 1 :
			   (m_InImage.data.image.format == Img::CF_RGB || m_InImage.data.image.format == Img::CF_PNG || m_InImage.data.image.format == Img::CF_JPEG) ? 3 :
	(m_Image.data.image.raw_data.length()/width/height);//チャンネル数の取得
      if(channels==3)//チャンネル数によるＭａｔのメモリ確保
	iamge.create(height,width,CV_8UC3);//8bit unsigned char型で３チャンネル(1pixelあたり３つ)
      else
	iamge.create(height,width,CV_8UC1);//8bit unsigned char型で1チャンネル(1pixelあたり1つ)

      long data_length=m_InImage.data.image.raw_data.length();//データポートから画像データの長さを取得

      if(m_InImage.data.inage.format==Img::CF_RGB)//データがRGB形式で送られてきている場合
	{
	  
	  for(int i=0;i<height;++i)//画像データを１行づつコピー
	    {
	      //memcpy(コピー先のポインタ,コピー元のポインタ,コピーするデータの長さ(バイト数))
	      //あるポインタから、指定のポインタに、指定された長さのメモリをコピーする
	      //sizeof(変数)
	      //引数で確保されているメモリをint型で返す
	      memcpy(&image.data[i*image.step],&m_InImage.data.image.raw_data[i*width*channels],sizeof(unsigned char)*width*channels);
	    }
	  
	  if(channels==3)//ＲＧＢの順番を変更(標準的に使われているカメラの出力の順番とOpenCVで用いられている順番が違うため)
	    {
	      cv::cvtColor(image,image,CV_RGB2BGR);//チャンネルの順番をＲＧＢからＢＧＲに変更
	    }
	  
	}
      else if(m_InImage.data.image.format==Img::CF_JPEG||m_InImage.data.image.format==Img::CF_PNG)//データがJPEC,PNG形式で送られてきた場合
	{
	  std::vector<uchar> compressed_image=std::vector<uchar>(data_length);//unsigned char型の配列をdata_length列文確保
	  //データコピー
	  memcpy(&compressed_image[0], &m_Image.data.image.raw_data[0], sizeof(unsigned char) * data_length);

	  //データのデコード
	  cv::Mat decode_image;
	  if(channnels==3)//3チャンネルの場合
	    {
	      decode_image=cv::imdecode(cv::Mat(compressed_image),CV_LOAD_IMAGE_COLOR);
	      cv::cvtColor(decoded_image,image,CV_RGB2BGR);
	    }
	  else
	    {
	      decoded_image=cv::imdecode(cv::Mat(compressed_image),CV_LOAD_IMAGE_GRAYSCALE);
	      image=decoded_image;
	    }
	}
      //画像データが入っている場合は画像を表示
      if(!image.empty())
	{
	  cv::imshow("Image Window",image);
	  cv::waitkey(3);
	}
      
    }
  return RTC::RTC_OK;
}

/*
RTC::ReturnCode_t SingleArUco::onAborting(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t SingleArUco::onError(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t SingleArUco::onReset(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t SingleArUco::onStateUpdate(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/

/*
RTC::ReturnCode_t SingleArUco::onRateChanged(RTC::UniqueId ec_id)
{
  return RTC::RTC_OK;
}
*/



extern "C"
{
 
  void SingleArUcoInit(RTC::Manager* manager)
  {
    coil::Properties profile(singlearuco_spec);
    manager->registerFactory(profile,
                             RTC::Create<SingleArUco>,
                             RTC::Delete<SingleArUco>);
  }
  
};


